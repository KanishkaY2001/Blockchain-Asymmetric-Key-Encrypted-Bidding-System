//==============================================================================//
//                      Certification Issuance Program                          //
//==============================================================================//



/**
 * Instructions to Organization:
 * =============================
 * --> (1) Install Node.js and npm
 * --> (2) Install Web3 through npm
 * --> (3) Install ethers through npm
 * 
 * Installation guides:
 * ====================
 * (1): https://docs.npmjs.com/downloading-and-installing-node-js-and-npm
 * (2): https://www.npmjs.com/package/web3
 * (3): https://www.npmjs.com/package/ethers
*/



//=======================================//
//          Initialize Libraries         //
//=======================================//



const ethers = require('ethers');
const Web3 = require("web3");
let web3 = new Web3(new Web3.providers.HttpProvider("http://127.0.0.1:8545"));



//=======================================//
//           Application Form            //
//=======================================//



// Organization has determined that the investor is eligible and has verified
// that the invstor owns both the public and private keys of their address.
// Organization's account, consisting of private and public keys (for signing):
const signerAuthorityAccount = web3.eth.accounts.create(web3.utils.randomHex(32));

// The application form functionality will be represented through a front-end online application form
// that the investor, wishing to verify themselves as a sophisticated investor, must complete successfully.
// The organization may provide instructions, code, or a software to enable investors to "Securely" generate a signature
function applicationForm() {
    // Investor's details:
    var investorAccount = web3.eth.accounts.create(web3.utils.randomHex(32));
    var investorAddress = investorAccount.address;

    // Message in the application form (to sign):
    const verificationMessage = "I control the private and public keys";

    // Investor locally signs the message with their private key using the following program logic
    // Once a 'investorSignature' is generated by the investor, they will submit this value to the form
    // The organization may choose to provide a secure method from which the investor can derive their 
    // signature without compromising their private key or any private information
    const signedVerificationMessage = web3.utils.keccak256(ethers.utils.solidityPack(["string"], [verificationMessage])).toString('hex');
    const investorSignature = web3.eth.accounts.sign(signedVerificationMessage, investorAccount.privateKey).signature;

    // Investor now provides public signature and wallet address (hashed public key) to application form:
    // Application form will take this information and call the function with parameters:
    function checkInvestorValidity(publicSignatureVerificationKey, address) {
        return address == web3.eth.accounts.recover(signedVerificationMessage, publicSignatureVerificationKey);
    }

    // return true If the information provided is correct (public key and private key are correlated with eachother)
    // then the organization verifies that the investor has control / ownership of the public and private keys.
    if (checkInvestorValidity(investorSignature, investorAddress)) createCertificate(investorAddress);

    // The certificate may be created from this point onward...
}



//=======================================//
//          Certificate Creation         //
//=======================================//



// The certificate creation process is performed in the backend of the organization, because it consists of
// private information pertaining to real-life people, and also the private key of the organization, which is
// highly suseptible to being compromised and misused. The parameter is the investor's public address
function createCertificate(_investorAddress) {

    // The organization performs this functionality locally to produce a certificate
    // The following encoded parameters represnt a message which signifies that the investor is verified for a particular year
    const encoded = ethers.utils.solidityPack(["string", "address", "string", "uint", "string"], 
    ["the owner of Ethereum address ", _investorAddress, " is a sophisticated investor for year ", new Date().getFullYear(), "."]);
    const signedCertificateMessage = web3.utils.keccak256(encoded).toString('hex');

    // The organization performs this logic locally, through backend, to ensure that their private key is not compromised
    // JavaScript frontend may be compromised as it is represented through plain text, so it is important to do this locally
    const publicSignatureVerificationKey = web3.eth.accounts.sign(signedCertificateMessage, signerAuthorityAccount.privateKey);

    // Verification information has been produced and can now be given to the investor to use as proof
    // that they are a sophisticated investor. This info is sent to the investor through an email.
    const verificationInformation = {
        signedMessage : publicSignatureVerificationKey.messageHash,
        signature : publicSignatureVerificationKey.signature
    }

    return verificationInformation;
}
module.exports.createCertificate = createCertificate;
module.exports.signerAuthorityAccount = signerAuthorityAccount;



//=======================================//
//          For Testing Purpose          //
//=======================================//


// The following code is not strictly used for certification or the application form, but complements the truffle testing process
// It is used to generate an X number of financial organizations which are able to sign messages, and allow investors to become
// sophisticated investors, if their public wallet address is provided as a paremeter.
function createCustomCertificate(_investorAddress) {
    const customAuthorityAccount = web3.eth.accounts.create(web3.utils.randomHex(32));

    const encoded = ethers.utils.solidityPack(["string", "address", "string", "uint", "string"], 
    ["the owner of Ethereum address ", _investorAddress, " is a sophisticated investor for year ", new Date().getFullYear(), "."]);
    const signedCertificateMessage = web3.utils.keccak256(encoded).toString('hex');
    const publicSignatureVerificationKey = web3.eth.accounts.sign(signedCertificateMessage, customAuthorityAccount.privateKey);

    const verificationInformation = {
        signedMessage : publicSignatureVerificationKey.messageHash,
        signature : publicSignatureVerificationKey.signature,
        signer: customAuthorityAccount.address
    }

    return verificationInformation;
}
module.exports.createCustomCertificate = createCustomCertificate;